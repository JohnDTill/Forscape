Every expression corresponds to a set of possible functions which could be the result of evaluation.
We denote this set of abstract functions ùîΩ
Every call has a list of parameter types, ‚Ñô
Based on ‚Ñô, we must instantiate every member of ùîΩ so that there is a set ‚ÑÇ of concrete functions
This forms the basis of static type checking.
Before making the call, we need a way to map the members of ùîΩ to the members of ‚ÑÇ.
This is trivial where ùîΩ and ‚ÑÇ have 1 member, which will be the vast majority of function calls.
In other cases, you would need a dynamic map.
I think it is okay if there is inherent dynamism which is usually optimised.

This will limit/challenge compilation.
alg echo(x) print(x)
alg doCall(f){
    f(1)
    f("2nd instantiation of f within the same body!")
}
doCall(echo)
f is passed once, but refers to two instantiations. This won't translate to most statically typed languages.
However, I like this idea of statically typed, dynamically mapped. It's interesting if nothing else.

For any function taking function arguments, you cannot be sure if it is already instantiated, as ùîΩ is not exactly a type
The simplest thing is to always reinstantiate
This is potentially wasteful since you are effectively currying any function taking function inputs
Practically, I don't think it will be bad

This should "just work" with closures - they are already set up in the abstract functions, and will be copied to instantiations

Recursion is a bit tricky
alg f(x){
    return h(x)
}
alg h(x){
    if(x > 0) return x + f(x-1)
    else return 0
}
h(3)
We need to take care we don't have instantiation cycles, but...
We will see that an instantiation of h is in progress and give up on instantiating f.
We shouldn't let this derail us.
Perhaps at each level, we should track the functions we tried to instantiate and failed.
Then when the return type is known, give type checking another go (error if return type is unknown).

What about returning functions? Then the function return type is ùîΩ, the set of all possible returned functions.
The type checking will occur at any callsites.

This isn't niche. Actually, one of the main language features is second-order operators like differentiation.
We need to calculate J(x) = ‚àÇf/‚àÇx. That is, partial differentiation takes a function input and returns a function output.
It is similar to the following:
alg funDecorator(f){
    alg decorated(){
        return 1 + f()
    }
    return decorated
}
alg f() return 1
dec = funDecorator(funDecorator(f))
print(dec())
First, you instantiate the inner call to funDecorator, then the outer call.
You'll instantiate instantiate decorated for the dec call, during which you'll instantiate f.
from funDecorated being instantiated twice, there are two abstract implementations of decorated
The case is a bit different with partial differentiation; you do want to differentiate at compile time.
You instantiate derivative funcs for each member of ùîΩ
The process is complicated... maybe it is sound.

What happens when you add integers and number types belong to a tree hierarchy?

DO THIS - implement and remove note